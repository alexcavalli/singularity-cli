#!/usr/bin/env ruby
require 'fileutils'
require_relative '../lib/singularity'

def print_usage
    puts <<END
# Usage:
#    singularity deploy <file.json> <release>
#       - deploy singularity job
#    singularity delete <file.json>
#       - delete singularity job
#    singularity run <commands>
#       - start new instance in singularity and run <commands>
#    singularity runx <commands>
#       - use this if "singularity run" fails
#       - same as "singularity run", but skips /sbin/my_init
#    singularity ssh
#       - start new box in singularity and SSH into it
END
end

action = ARGV[0]

File.file?('mesos-deploy.yml') and File.file?('.mescal.json') or puts 'Please do this command from a project directory (where both mesos-deploy.yml and .mescal.json exist).'

uri = YAML.load_file(File.join(Dir.pwd, 'mesos-deploy.yml'))['singularity_url']

case action
  when "delete"
    print_usage unless ARGV.size == 2
    data = JSON.parse(File.read(ARGV[1]))
    request = Singularity::Request.new(data, uri, nil)
    request.delete

  when "deploy"
    print_usage unless ARGV.size == 3
    data = JSON.parse(File.read(ARGV[1]))
    release = ARGV[2]
    request = Singularity::Request.new(data, uri, release)
    request.create
    request.deploy

  when "run"
    ARGV.shift
    Singularity::Runner.new(ARGV, uri).run

  when "runx"
    # this option is to skip the use of /sbin/my_init: some commands won't run correctly when both are used
    Singularity::Runner.new(ARGV, uri).run

  when "ssh"
    # copy the docker mounted ssh files and chown them to work inside the container
    if Dir.exists?('/ssh')
      FileUtils.copy_entry '/ssh', '/root/.ssh'
      FileUtils.chown_R 'root', 'root', '/root/.ssh'
    end
    Singularity::Runner.new(ARGV, uri).run

  else
    print_usage

end



